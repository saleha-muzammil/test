# -*- coding: utf-8 -*-
"""L200973_AI_LAB4 (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1o2qag35L9acfEGO20BsDcP3o2YsCwfj2

Header files
"""

from queue import PriorityQueue
import copy
import pathlib
import plotly.express as p
import numpy as n

"""reading from file"""

def readFromFile(name):
  matrix = []
  startindex = 0
  endindex = 0

  with open(name,'r') as input:
    for i , line in enumerate(input):
      r = []

      for j , c in enumerate(line.strip()):
        if c == 'S':
          startindex = (i,j)
          r.append(0)
        elif c == 'G':
          endindex = (i,j)
          r.append(0)
        elif c =='0' or c =='1' or c =='2':
          r.append(int(c))
      matrix.append(r)
    
    return matrix , startindex , endindex

"""Visualize the path using Plotly"""

def visualize(matrix , path , no):
  
  _matrix = copy.deepcopy(matrix)

  for i , j in path:
    _matrix[i][j] = 5
  
  fig = p.imshow(_matrix , title = no)
  fig.show()

def viewpath( matrix , path , no):
  #np.reshape(matrix(7,7))
  _matrix = copy.deepcopy(matrix)
  
  for x , y in path:
    _matrix[x][y] = 5

  if no ==1:
    fig = p.imshow(_matrix , title = "BFS ALGO")
    fig.show()
  elif no ==2:
     fig = p.imshow(_matrix , title = "DFS ALGO")
     fig.show()

"""print path"""

def printP(path):
   if path == -1:
        print("No path found.")
   else:
        for node in path:
            print(node)

"""Find path"""

def AstarAlgo(matrix , start , end):

  AstarQueue = PriorityQueue()
  AstarQueue.put(start,0)

  prevNode = {start: None}
  pathcost = {start:0}

  while not AstarQueue.empty():
    curr = AstarQueue.get()

    if curr == end:

      traversal= []
      while curr != start:
        traversal.append(curr)
        curr = prevNode[curr]
      
      traversal.append(start)
      traversal.reverse()
      return traversal
    
    for next in nextNode(matrix , curr):
      updatedCost =  pathcost[curr] + 1
      if next not in pathcost or updatedCost < pathcost[next]:
        pathcost[next] = updatedCost
        p = updatedCost + calcHeuristicVal(end,next)
        AstarQueue.put(next,p)
        prevNode[next] = curr
  
  return None

"""Calculate Next Node"""

def nextNode( matrix , currState):

  row , column = currState
  next = []
  for r , c in [(1,0) , (0,1) , (-1 , 0) , (0,-1)]:
    n_row = row + r
    n_col = column + c

    if n_row < 0 or n_row >= len(matrix) or n_col < 0 or n_col >= len(matrix[0]):
      continue
    
    index = matrix[n_row][n_col]

    if index == 1:
      continue
    elif index == 2:
      n_row = n_row + r
      n_col = n_col + c

      if n_row < 0 or n_row >= len(matrix) or n_col < 0 or n_col >= len(matrix[0]):
        continue
      index =  matrix[n_row][n_col]
      if index == 1:
        continue 
    next.append((n_row,n_col))
  return next

"""Calculating Heuristic value"""

def calcHeuristicVal( c1 , c2):
  heuristicVal =  (abs(c1[0]-c2[0]) + abs(c1[1] - c2[1]))
  return heuristicVal

"""BFS and DFS Neighbours"""

def neighbors(index, matrix):
    x = len(matrix)
    y = len(matrix[0])
    i, j = index
    
    neighbor_index = []
    if i > 0 and matrix[i-1][j] == 0: 
        neighbor_index.append((i-1, j))

    if i < x-1 and matrix[i+1][j] == 0: 
        neighbor_index.append((i+1, j))

    if j > 0 and matrix[i][j-1] == 0:  
        neighbor_index.append((i, j-1))

    if j < y-1 and matrix[i][j+1] == 0: 
        neighbor_index.append((i, j+1))
    return neighbor_index

"""Find Path for BFS and DFS"""

def findpath(paths, index, start):

    if index == start:
        return [start]

    return findpath(paths, paths[index], start) + [index]

"""DFS Algorithm"""

def dfssearch(matrix, start, end):
   
    dfs_stack = [start]
    node_visited = set()
    traversal = {}
    while dfs_stack:
        index = dfs_stack.pop()
        if index == end:
            return findpath(traversal, index, start)
        node_visited.add(index)

        for neighbor in neighbors(index, matrix):
            if neighbor not in node_visited:
                dfs_stack.append(neighbor)
                traversal[neighbor] = index
    return -1

"""BFS Algorithm"""

def bfssearch(matrix, start, end):
    bfsqueue = [start]
    node_visited = set()
    paths = {}

    while bfsqueue:
        index = bfsqueue.pop(0)
        if index == end:
            return findpath(paths, index, start)
        node_visited.add(index)

        for neighbor in neighbors(index, matrix):
            if neighbor not in node_visited:
                bfsqueue.append(neighbor)
                node_visited.add(neighbor)
                paths[neighbor] = index
    return -1

"""main function"""

def main():

  
  
  matrix, start, goal = readFromFile('file.txt')
  #BFS algorithm
  bfs = bfssearch(matrix, start,goal)
  print(" PATH GENERATED BY BFS")
  printP(bfs)
  visualize(matrix , bfs , "BFS ALGORITHM")

  #DFS algorithm
  dfs = dfssearch(matrix, start,goal)
  print(" PATH GENERATED BY DFS")
  printP(dfs)
  visualize(matrix , dfs , "DFS ALGORITHM")

  matrix , start , goal = readFromFile("input.txt")
  #A* algorithm
  traversal = AstarAlgo(matrix , start , goal)
  print(" PATH GENERATED BY A* ALGORITHM")
  printP(traversal)
  visualize(matrix , traversal , "A* ALGORITHM")



if __name__ == "__main__":
  main()